```text
从http到jwt——浏览器是如何记录登录状态的
其他
2022-08-04
https://picgo.kwcoder.club/202208/202208160012657.png
```

# HTTP协议——无状态

## HTTP简介及特点

HTTP是一个应用层的、面向对象的协议，其特点有：

- 支持客户端/服务器模式
- 简单快速
- 灵活
- 无连接
- 无状态

> 需要事先记住的一句话：标准的HTTP协议是无状态的、无连接的，标准的HTTP协议是不包含cookie、session、application等的。

## 无连接

无连接的含义是限制每次连接只处理一个请求。

HTTP协议诞生于互联网，服务器需要同时处理面向全球各地的、数十万甚至数百万的客户端的网页访问。然而每个客户端与服务器之间交换数据的间歇性较大，数据传输具有突发性、瞬时性，并且网页浏览的发散性导致两次传送数据的关联性不高，大部分通道会空闲，导致无端占用资源。
因此HTTP的设计利用这种特点将协议设计为请求时连接、结束时释放，以达到尽快释放资源的目的。

随着科技的发展，网页中嵌入图片、视频等大型文件的场景越来越多。而根据HTTP协议每次访问图片都需要建立一次TCP连接，导致加载一个网页需要建立多次连接，导致了效率低下。
于是Keep-Alive被提出来，Keep-Alive可以实现客户端和服务端的连接持续有效，当出现对服务器的后继请求时，依赖于Keep-Alive可以不用重新建立连接。
当然Keep-Alive并不是万能的，它的优点就是它的缺点，因为需要保持连接持续有效，就必然造成资源浪费。

## 无状态

标准的HTTP协议是无状态的。

HTTP协议是没有记忆能力的，即无论来自于哪台主机、哪个路径的请求，都是无记忆的。正是因为HTTP协议没有记忆能力，因此标准的HTTP协议是无法分辨请求是谁发送的，服务器必须也只能按照预定逻辑从0开始响应。

> 现象举例：
> 1、用户A向服务器发送请求1和请求2，服务器是无法判断请求1和请求2来自于同一个用户。
> 2、用户A向服务器发送请求1，用户2向服务器发送请求2，服务器是无法判断这两个请求是不是来自于同一个用户。

这么设计的好处：

1. 一个HTTP请求可能需要经过网关的代理转发，而因为HTTP是无状态的，所以在转发、代理、过滤的过程中是不需要对任何信息进行处理的，只需要知道该请求是向谁发送的即可，增加效率且不易出错。
2. 不需要服务器记录状态，节省资源。
3. 每一个请求都是独立的，是互不影响的。


存在的问题：当需要产生交互时，必须要让服务器能够分辨主机，而无状态无法实现。


# Cookie和Session

## Cookie

Cookie的诞生是为了解决HTTP无状态的特性无法满足交互式WEB。

服务器在收到客户端请求后，服务器响应附带Set-Cookie的头部信息，客户端保存Cookie。在之后的所有请求中，客户端会自动携带Cookie信息。

> 场景：当用户访问一个需要登录的资源时，可以将账户和密码保存在Cookie中，这样每次发送请求都会携带带有账户和密码的Cookie，服务器就可以对账户信息进行验证。

然而将账户密码这类敏感数据存储在浏览器的Cookie中，每次发送请求都携带这样的Cookie，会造成如下两个严重的问题：

- 携带账户密码信息发送请求是非常不安全的，一旦请求被拦截，将会造成密码泄漏的严重情况
- 在服务器端每次都需要对账户密码进行验证，需要消耗大量的资源。


## Session

在引入会话（Session）后，便可以解决这个问题。

当客户端向服务器发起请求后，服务器会对每一个浏览器创建一个会话对象。浏览器第一次请求服务器时，服务器会为这个浏览器生成一个session对象并保存在服务器端，把session的id以cookie的形式发送给客户端。
这样当客户端请求服务器时，服务器只需要通过cookie中的sessionId来辨别客户端的状态和分辨用户。并且sessionId从字面上看没有任何意义，仅是代表服务器中的session对象的id，即便请求被拦截也不会对服务器或用户造成一些危险的情况。

# 中间件

随着用户量的增加和业务的扩展，分布式应用应运而生。此时传统的Cookie和Session已经无法满足当前的需求了。

因为Session是保存在服务器中的，而在分布式场景中，用户的两次请求可能会被转发到不同的服务器中，这是如果想要保证两台服务器中都需要有用户对应的session，就必须实现两台服务器的session统一，如果是一个非常大的系统，session的资源消耗可能会非常大，这对分布式系统的开发是非常不利的。

对于这个问题，最好的解决办法就是将session保存到一个固定的、中间存储的数据库中，当客户端发起请求时，无论被转发到哪台服务器，服务器可以直接去中间存储的数据库中获取用户的session对象，这被称之为中间件**（常见的实现方式为使用Redis中间件）**。

> 粗暴架构师：遇到问题加一层

在此场景下，当一个客户端第一次向服务器发起请求时，服务器会生成一个类session对象并保存在Redis中，把这个类session对象的id以cookie的形式发送给客户端。客户端在后续的请求中，服务器获取cookie中的类session的id，使用这个id去中间件中去查询对应的对象，以此解决跨服务器的请求问题。

# Token

通过Redis实现的跨服务器访问是一个非常好的实现方式，如果有一种途径可以实现将必要的信息通过防伪的手段保存在客户端，就可以完全抛弃中间件来完成对客户端的标记了，这种技术被称为Token技术，最典型的便是jwt（JSON Web Token）。

jwt是一种以紧凑和自包含的开放标准，其格式为`xxxx.yyyy.zzzz`，由三部分组成，分别是`header`、`payload`、`signature`。
其中`header`的值通常为算法和类型的JSON字符串的base64编码；`payload`为有效负载的base64编码；`signature`是`header`和`payload`的base64编码和一个盐在一起的签名。

例如，若使用HAS256加密算法，则一个jwt可以表示为：

- `header`：`base64UrlEncode(header)`
- `payload`：`base64UrlEncode(payload)`
- `signature`：`HAS256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`

> base64是一个编码格式，不是加密算法，可以通过工具或算法进行反编码，因此非常不建议将敏感信息放入负载。
> 其中secret为自定义的、用户加密的盐，一旦泄漏就意味着外界可以通过猜测加密算法的方式，完全获取系统的整个认证规则，后果非常严重。


当客户端向服务器请求登录时，服务器会验证账号密码的正确性，如果正确则允许用户登录。
然后可以将用户的用户名、用户的权限保存在`payload`中（`header`和`signature`由工具类自己生成，前提是需要提供`secret`）。
当客户端再次请求服务器时，服务器会根据`header`和`payload`以及系统设置的`secret`判断该令牌是否为正确的令牌，首先会判断加密算法是否正确，其次会判断令牌是否被篡改，然后会判断该令牌是否已经过期。
若验证通过，即可从`payload`中获取预存的信息，以供系统调用授权等。
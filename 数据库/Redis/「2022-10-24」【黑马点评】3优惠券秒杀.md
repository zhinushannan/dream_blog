```text
【黑马点评】3优惠券秒杀
2022-10-24
数据库>Redis
```

# 全局ID

在秒杀场景中，需要保存订单的信息，其中必然需要记录订单的ID，而在使用MySQL自增ID时会存在如下问题：

- ID的规律性太明显（能猜测到一些机密）
- 受单表数据量的限制

利用ID生成器可以解决在分布式场景下的全局唯一ID问题，一般符合下列特性：

- 唯一性
- 高可用：需要保证任何时刻都可以使用
- 高性能
- 递增性：不能连续递增，但要单调递增，为了让数据库更好的建立索引
- 安全性

设计如下全局唯一ID：

<img src="https://picgo.kwcoder.club/202208/202210261924751.png" alt="image-20221026192411047" style="zoom:50%;" />

该全局唯一ID共64位：

- 第一位是代表符号位
- 第2-32位代表秒级时间戳
- 第33-64位代表序列号

```java
package com.hmdp.utils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;

/**
 * @author zhinushannan
 */
@Component
public class RedisIdWorker {

    /**
     * 开始的时间戳
     */
    private static final long BEGIN_TIMESTAMP = 1640995200L;

    /**
     * 位移位数
     */
    private static final int COUNT_BITS = 32;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    public long nextId(String keyPrefix) {
        // 1. 生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowSecond - BEGIN_TIMESTAMP;

        // 2. 生成序列号
        // 2.1 获取当前日期，精确到天
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        // 2.2 自增长：存在则+1，不存在则设置位1
        long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);

        // 3. 拼接并返回
        // 将时间戳向左移动31位，然后和序列号做或运算
        return timestamp << COUNT_BITS | count;
    }

}
```

生成全局唯一ID的其他策略：

- UUID
- Redis自增
- 雪花算法（需要维护系统变量）
- 数据库自增（批量获取ID，本地程序缓存，以提高效率）

# 实现优惠券秒杀下单

首先使用接口测试工具向`http://localhost:8081/voucher/seckill`POST请求发送如下数据，需要保证`beginTime`在当前时间之前、`endTime`要在当前时间之后：

```json
{
    "shopId": 1,
    "title": "100元代金券",
    "subTitle": "周一至周五均可使用",
    "rules": "全场通用\\n无需预约\\n可无限叠加\\n不兑现、不找零\\n仅限堂食",
    "payValue": 8000,
    "actualValue": 10000,
    "type": 1,
    "stock": 100,
    "beginTime": "2022-09-26T10:09:17",
    "endTime": "2022-12-26T23:09:04"
}
```

实现优惠券秒杀下单功能需要重视：

- 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
- 库存是否充足，不足则无法下单

## 实现优惠券下单功能

修改`VoucherOrderController`：

```java
package com.hmdp.controller;


import com.hmdp.dto.Result;
import com.hmdp.service.IVoucherOrderService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author 虎哥
 * @since 2021-12-22
 */
@RestController
@RequestMapping("/voucher-order")
public class VoucherOrderController {

    @Autowired
    private IVoucherOrderService voucherOrderService;

    @PostMapping("seckill/{id}")
    public Result seckillVoucher(@PathVariable("id") Long voucherId) {
        return voucherOrderService.seckillVoucher(voucherId);
    }
}
```

编辑`VoucherOrderServiceImpl.seckillVoucher`函数：

```java
    @Override
    @Transactional
    public Result seckillVoucher(Long voucherId) {
        // 1. 查询优惠券
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        // 2. 判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            // 尚未开始
            return Result.fail("秒杀尚未开始！");
        }
        // 3. 判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            // 已经结束
            return Result.fail("秒杀已经结束！");
        }
        // 4. 判断库存是否充足
        if (voucher.getStock() < 1) {
            // 库存不足
            return Result.fail("库存不足！");
        }
        // 5. 扣减库存
        boolean success = seckillVoucherService
                .update()
                .setSql("stock = stock - 1")
                .eq("voucher_id", voucherId)
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }
        // 6. 创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        voucherOrder.setUserId(UserHolder.getUser().getId());
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);
        // 7. 返回订单id
        return Result.ok(orderId);
    }
```


```text
Zookeeper简介
运维>Zookeeper
2022-07-17
https://picgo.kwcoder.club/202208/202207201246242.png
```

# Zookeeper是什么

Zookeeper是一个分布式的、开源的[分布式应用程序协调服务](/p/20220716/)。是Hadoop和HBase的重要组件，他是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。

官网：[https://zookeeper.apache.org/](https://zookeeper.apache.org/)
源码：[https://github.com/apache/zookeeper](https://github.com/apache/zookeeper)

> Zookeeper的来源（摘自《从Paxos到Zookeeper》）：
> Zookeeper 最早起源于雅虎研究院的一个研究小组。在当时，研究人员发现，在雅虎内部很多大型系统基本都需要依赖一个类似的系统来进行分布式协调，但是这些系统往往都存在分布式单点问题。所以，雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架，以便让开发人员将精力集中在处理业务逻辑上。
> 关于“ZooKeeper”这个项目的名字，其实也有一段趣闻。在立项初期，考虑到之前内部很多项目都是使用动物的名字来命名的（例如著名的Pig项目),雅虎的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 RaghuRamakrishnan 开玩笑地说：“在这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，雅虎的整个分布式系统看上去就像一个大型的动物园了，而 Zookeeper 正好要用来进行分布式环境的协调一一于是，Zookeeper 的名字也就由此诞生了。

# Zookeeper可以做什么

## 分布式服务注册与订阅

在分布式环境中，为了保证高可用性，通常同一个应用或同一个服务的提供方会部署多份，达到负载均衡。
消费者需要在这些对等的服务器中选择一个来执行相关的业务逻辑，比较典型的有Dubbo。

## 分布式配置中心

发布者将数据发布到ZK节点上，供订阅者获取数据，实现配置信息的集中式管理和动态更新。

## 命名服务

通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。
被命名的实体通常可以是集群中的机器，提供的服务地址，进程对象等——这些信息都可以统称为Name。
较为常见的是一些分布式服务框架中的服务地址列表，通过调用ZK提供的创建节点的API，能够很容易的创建一个全局唯一PATH，这个PATH就可以作为一个Name。

## 其他

此外，Zookeeper还可以提供分布式锁、Master选举、负载均衡服务。

# Zookeeper的特点

- 顺序一执行：从同一客户端发起的事务请求，最终会严格地按照顺序被应用到zookeeper中去。
- 原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么真个集群中所有机器都成功应用了某一事物，要么都没有应用。
- 单一系统映像：无论客户端连接到哪一个Zookeeper服务器上，其看到的服务端数据模型都是一致的。
- 可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。



# Zookeeper的设计目标

- 简单的数据结构：Zookeeper使分布式程序能够通过一个共享的属性结构的命名空间来进行相互协调，即Zookeeper服务器内存中的数据模型由一系列被称为ZNode数据节点组成的，Zookeeper将全部的数据存储在内存中，以达到提高服务器吞吐，减少延迟的目的。
- 构建集群：Zookeeper集群通常有一组机器构成，组成Zookeeper集群的每台机器都会在内存中维护当前服务器的状态，并且每台机器之间都互相通信。
- 顺序访问：Zookeeper会对每个来自客户端的每个更新请求分配一个全局唯一的递增编号，这个编号代表事务操作的先后顺序，保证了顺序访问。
- 高性能：Zookeeper的全部数据都存储在内存中，100%读请求测压QPS大于10万。


# Zookeeper集群

## 集群

Zookeeper是一个由多个server组成的集群，一个leader、多个follower。leader为客户端服务器提供读写服务，follower只能提供读服务。

leader实时更新请求转发，由leader实施更新请求顺序进行，来自同一个客户端的更新请求按其发送顺序依次原子性执行数据更新。

每个server保存的数据全部一致，全局唯一数据视图，所以客户端无论连接哪个server，数据视图都是一致的实时性，在一定时间范围内，客户端嫩个够读到最新数据。


## 角色


Zookeeper中有Leader和Follower两种角色，Leader是集群工作机制的核心，是集群的主节点，负责响应所有对Zookeeper状态变更的请求。

主要工作：

- 事务请求的唯一调度和处理，保障集群处理事务的顺序性
- 集群内各服务器的调度者


Follower的工作有：

- 响应本服务器上的读请求
- 处理leader的提议，并在leader提交该提议时在本地也进行提交

此外，还有一个特殊的角色——Observer，充当观察者的角色，如果Zookeeper集群的读负载很高，或者客户端跨机房，可以设置一些observer服务器，以提高读的吞吐量。
Observer和Follower比较相似，区别在于Observer不属于法定人数，既不参加选举也不响应提议。同时，Observer不需要将事务持久化到磁盘，一旦Observer重启，需要从leader重新同步整个命名空间。

### Leader的产生

Zookeeper的Leader不是指定的，而是选举。
Leader选举是Zookeeper最重要的技术之一，也是保障分布式数据一致性的关键所在。

在服务器集群初始化阶段，当多台服务器启动后，每台机器都试图存照一个Leader，于是进入leader选举流程：

1. 每个server发出一个投票，投票最基本的元素是SID（服务器ID）和ZXID（事务ID）
2. 接受来自各个服务器的投票
3. 处理投票：按照ZXID进行选举，ZXID相同时，使用SID辅助选举

### Leader产生原则

担任Leader的节点获得的票数应当大于集群机器数量的一般，即大于或等于(n/2+1)。


| 集群数量 | 至少正常运行数量 | 允许挂掉的数量 |
| :------: | :--------------: | :------------: |
|    2     |   2/2 + 1 = 2    |       0        |
|    3     |   3/2 + 1 = 2    |       1        |
|    4     |   4/2 + 1 = 3    |       1        |
|    5     |   5/2 + 1 = 3    |       2        |
|    6     |   6/2 + 1 = 4    |       2        |

通过上表可以发现，3台服务器和4台服务器都最多允许1台服务器挂掉，5台服务器和6台服务器都最多允许2台服务器挂掉，4台服务器成本高于3台服务器成本，6台服务器成本高于5服务器成本，所以Zookeeper推荐使用单数机数的集群。

### 服务器状态

确定Leader之后，服务器就会更改自己的状态。
一般情况下，确定状态后不会再发生变化，比如新机器加入、一台非leader集群挂掉。


# Zookeeper会话

## 会话（Session）

Session 指的是 ZooKeeper 服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。


在Zookeeper客户端与服务端成功完成连接创建后，就创建了一个会话，Zookeeper会话在整个运行期间的生命周期中，会在不同的会话状态中之间进行切换，这些状态可以分为CONNECTING、CONNECTED、RECONNECTING、RECONNECTED、CLOSE等。

一旦客户端开始创建Zookeeper对象，那么客户端状态就会变成CONNECTING状态，同时客户端开始尝试连接服务端，连接成功后，客户端状态变为CONNECTED，通常情况下，由于断网或其他原因，客户端与服务端之间会出现断开情况，一旦碰到这种情况，Zookeeper客户端会自动进行重连服务，同时客户端状态再次变成CONNCTING，直到重新连上服务端后，状态又变为CONNECTED，在通常情况下，客户端的状态总是介于CONNECTING 和CONNECTED 之间。但是，如果出现诸如会话超时、权限检查或是客户端主动退出程序等情况，客户端的状态就会直接变更为CLOSE状态。


## 会话创建

Session是Zookeeper中的会话实体，代表了一个客户端会话，其包含了如下四个属性

- sessionID：会话ID，是用来标识会话的唯一标识符，每次客户端创建新的会话时，Zookeeper都会为其分配一个全局唯一的sessionID。
- TimeOut：会话超时时间，客户端在构造Zookeeper实例时，会配置sessionTimeout参数用于指定会话的超时时间，Zookeeper客户端向服务端发送这个超时时间后，服务端会根据自己的超时时间限制最终确定会话的超时时间。
- TickTime：下次会话超时时间点，为了便于Zookeeper对会话实行"分桶策略"管理，同时为了高效低耗地实现会话的超时检查与清理，Zookeeper会为每个会话标记一个下次会话超时时间点，其值大致等于当前时间加上TimeOut。
- isClosing：标记一个会话是否已经被关闭，当服务端检测到会话已经超时失效时，会将该会话的isClosing标记为已关闭，已确保不再处理来自该会话的新请求了。


Zookeeper为了保证请求会话的全局唯一性，在SessionTracker初始化时，调用initializeNextSession方法生成一个sessionID，之后在Zookeeper运行过程中，会在该sessionID的基础上为每个会话进行分配，初始化算法如下


## 会话管理

Zookeeper的会话管理主要是通过SessionTracker来负责，其采用了分桶策略（将类似的会话放在同一区块中进行管理）进行管理，以便Zookeeper对会话进行不同区块的隔离处理以及同一区块的统一处理。

# Zookeeper的一些其他重要概念

## 数据节点ZNode

### 数据节点

在Zookeeper中，"节点"分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。
Zookeeper将所有数据存储在内存中，数据模型是一棵树（Znode Tree)，由斜杠（/）的进行分割的路径，就是一个Znode，例如/foo/path1。每个上都会保存自己的数据内容，同时还会保存一系列属性信息。

### 节点类型

在Zookeeper中，node可以分为持久节点和临时节点和顺序节点三大类。
可以通过组合生成如下四种类型节点：

- PERSISTENT：持久节点，节点创建后便一直存在于Zookeeper服务器上，直到有删除操作来主动清楚该节点。
- PERSISTENT_SEQUENTIAL：持久顺序节点，相比持久节点，其新增了顺序特性，每个父节点都会为它的第一级子节点维护一份顺序，用于记录每个子节点创建的先后顺序。在创建节点时，会自动添加一个数字后缀，作为新的节点名，该数字后缀的上限是整形的最大值。
- EPEMERAL：临时节点，临时节点的生命周期与客户端会话绑定，客户端失效，节点会被自动清理。同时，Zookeeper规定不能基于临时节点来创建子节点，即临时节点只能作为叶子节点。
- EPEMERAL_SEQUENTIAL：临时顺序节点,在临时节点的基础添加了顺序特性。

## 版本

每个数据节点都具有三种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。

- version：当前数据节点数据内容的版本号
- cversion：当前数据子节点的版本号
- aversion：当前数据节点ACL变更版本号

上述各版本号都是表示修改次数，如version为1表示对数据节点的内容变更了一次。即使前后两次变更并没有改变数据内容，version的值仍然会改变。version可以用于写入验证，类似于CAS。

## 事件监听器

ZooKeeper允许用户在指定节点上注册一些Watcher，当数据节点发生变化的时候，ZooKeeper服务器会把这个变化的通知发送给对应的客户端。

## ACL权限控制

ACL是Access Control Lists的简写， ZooKeeper采用ACL策略来进行权限控制，有以下权限：

- CREATE：创建子节点的权限 
- READ：获取节点数据和子节点列表的权限 
- WRITE：更新节点数据的权限 
- DELETE：删除子节点的权限 
- ADMIN：设置节点ACL的权限

## Paxos算法

Paxos算法是基于消息传递且具有高度容错特性的一致性算法，是目前公认的解决分布式一致性问题最有效的算法之一。